<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Virtualization on GSoC 25: Roadmap</title>
    <link>//localhost:60509/tags/virtualization/</link>
    <description>Recent content in Virtualization on GSoC 25: Roadmap</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 13 May 2025 10:10:25 -0400</lastBuildDate><atom:link href="//localhost:60509/tags/virtualization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Virtualization Basics</title>
      <link>//localhost:60509/posts/virtualization-fundamentals/</link>
      <pubDate>Tue, 13 May 2025 10:10:25 -0400</pubDate>
      
      <guid>//localhost:60509/posts/virtualization-fundamentals/</guid>
      <description>&lt;p&gt;Virtualization allows for the multiplexing of different operating systems on the same hardware. This allows for better utilization of system resources and greater flexibility, enabling common processes such as cloud computing.&lt;/p&gt;
&lt;h2 id=&#34;virtual-machine-monitors-vmm&#34;&gt;Virtual Machine Monitors (VMM)&lt;/h2&gt;
&lt;p&gt;A VMM, or a hypervisor, is at the heart of system virtualization. A VMM allows multiple virtual machines to run on a physical machine, much like an operating system allows multiple processes to run on a CPU.&lt;/p&gt;</description>
      <content>&lt;p&gt;Virtualization allows for the multiplexing of different operating systems on the same hardware. This allows for better utilization of system resources and greater flexibility, enabling common processes such as cloud computing.&lt;/p&gt;
&lt;h2 id=&#34;virtual-machine-monitors-vmm&#34;&gt;Virtual Machine Monitors (VMM)&lt;/h2&gt;
&lt;p&gt;A VMM, or a hypervisor, is at the heart of system virtualization. A VMM allows multiple virtual machines to run on a physical machine, much like an operating system allows multiple processes to run on a CPU.&lt;/p&gt;
&lt;p&gt;A VMM performs a &amp;ldquo;machine switch&amp;rdquo;, which is the analog of an operating system context switch.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//localhost:60509/images/virtualization/VMM.png&#34; alt=&#34;VMM&#34;&gt;&lt;/p&gt;
&lt;p&gt;There are some problems in this analogy, however. In a virtual machine, the guest OS expects unrestricted access to hardware (like running privileged instructions). Additionally, a single guest cannot get access to all resources of the machine. Thus, VMMs are designed with special considerations.&lt;/p&gt;
&lt;h3 id=&#34;trap-and-emulate&#34;&gt;Trap and Emulate&lt;/h3&gt;
&lt;p&gt;User proccesses run in ring 3, OS runs in ring 0. Privileged instructions only run in ring 0. What if the guest OS runs in ring 1, and traps to the VMM in ring 0?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//localhost:60509/images/virtualization/VMM.png&#34; alt=&#34;Trap and Emulate&#34;&gt;&lt;/p&gt;
&lt;p&gt;If the guest:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Makes a system call or interrupt: The guest process will trap to the VMM (ring 0), which will redirect to the guest OS trap handler. As far as the guest OS is concerned, they simply made a system call to the OS.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Returns from trap: Guest OS returns to the VMM, which redirects back to the user process&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;issues-with-this-approach&#34;&gt;Issues with this approach&lt;/h4&gt;
&lt;p&gt;Some registers in x86 show the privelege level. The Guest OS may not operate properly knowing it is in Ring 1 (ex: &lt;code&gt;eflags&lt;/code&gt;). Additionally, certain sensitive instructions (those that modify hardware state) can run in privileged and unprivileged modes and therefore do not trap to the VMM.&lt;/p&gt;
&lt;p&gt;According to the &lt;a href=&#34;https://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements&#34;&gt;Popek-Goldberg Theorem&lt;/a&gt; trap-and-emulate model only works if all sensitive instructions are subsets of privileged instructions. x86 does not satisfy this criteria.&lt;/p&gt;
&lt;h3 id=&#34;hardware-assisted-virtualization&#34;&gt;Hardware assisted virtualization&lt;/h3&gt;
&lt;p&gt;The most common type of virtualization today (used by KVM/QEMU) is hardware assisted virtualization. With this method, the CPU has a special VMX mode of execution.&lt;/p&gt;
&lt;p&gt;With VMX, x86 has 4 rings on non-VMX root mode, and 4 rings in VMX mode. The VMM enters VMX mode to run the guest OS in a ring 0 (albeit a less powerful VMX ring 0).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//localhost:60509/images/virtualization/HardwareVirtualization.png&#34; alt=&#34;Hardware Virtualization&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;kvmqemu-architecture&#34;&gt;KVM/QEMU Architecture&lt;/h3&gt;
&lt;p&gt;When the underlying processor supports &lt;code&gt;Intel VT-X&lt;/code&gt; or &lt;code&gt;AMD-V&lt;/code&gt;, we can use hardware-assisted virtualization.&lt;/p&gt;
&lt;p&gt;QEMU is a regular userspace process, that communicates with KVM via  &lt;code&gt;/dev/kvm&lt;/code&gt; device &lt;code&gt;ioctls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;QEMU allocates memory via &lt;code&gt;mmap&lt;/code&gt; system call for each guest VM, and creates one thread per vCPU in the guest.&lt;/p&gt;
&lt;p&gt;Therefore, the general control loop looks something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;open&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;dev&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;kvm)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ioctl&lt;/span&gt;(qemu_fd, KVM_CREATE_VM)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ioctl&lt;/span&gt;(vm_fd, KVM_CREATE_VCPU)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(;;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a6e22e&#34;&gt;ioctl&lt;/span&gt;(vcpu_fd, KVM_RUN)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt;(exit_reason) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; KVM_EXIT_IO: &lt;span style=&#34;color:#75715e&#34;&gt;// do I/O in qemu
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; KVM_EXIT_HLT:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;vmexits&#34;&gt;VMExits&lt;/h4&gt;
&lt;p&gt;So when must the guest OS return back to the hypervisor? Whenever this happens, it is known as a VM exit. This is when the CPU transitions from VMX non-root mode to the hypervisor running in VMX root mode.&lt;/p&gt;
&lt;p&gt;VM Exits happen whenever the guest performs an operation requiring hypervisor intervention.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Privileged Instructions&lt;/li&gt;
&lt;li&gt;Memory Access violations (EPT violations): Accessing unmapped physical address, MMIO, ROM&lt;/li&gt;
&lt;li&gt;Interrupts and Exceptions: Hardware interrupts delivered to the host, exception, or software interrupts. VMM must decide whether to inject interrupt into guest, emulate, or handle on host&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When a VM Exit is triggered and control is handed back to the hypervisor, the hypervisor either handles the simple exit itself, or forwards the exit to QEMU.&lt;/p&gt;
&lt;h4 id=&#34;vmx-mode&#34;&gt;VMX mode&lt;/h4&gt;
&lt;p&gt;Special CPU instructions enter VMX mode.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VMLAUNCH, VMRESUME  are invoked by KVM to enter VMX mode&lt;/li&gt;
&lt;li&gt;VMEXIT is invoked to exit VMX mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU switches context between host OS and guest OS. During the mode switch, CPU context is stored in the VMCS (VM control structure).&lt;/p&gt;
&lt;p&gt;VMCS stores the state of the guest, state of the host, and control fields that dictate how a VM operates. Each vCPU has its own VMCS managed by the hypervisor. This allows the system to easily switch between guest and host state.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;//localhost:60509/images/virtualization/qemuKVM2.png&#34; alt=&#34;Qemu &amp;#43; KVM&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;memory-virtualization&#34;&gt;Memory Virtualization&lt;/h2&gt;
&lt;p&gt;Typically, the guest page table has a Guest Virtual Address (GVA) -&amp;gt; Guest Physical Address (GPA) via its page table. Then, the VMM features an additional layer of indirection through the GPA-&amp;gt;Host Physical Address (HPA) mapping.&lt;/p&gt;
&lt;p&gt;Therefore, the guest&amp;rsquo;s &amp;ldquo;RAM&amp;rdquo; pages are distributed across host memory. With Extended Page Tables support (EPT), we can allow the system to walk two separate page tables for address translation.&lt;/p&gt;
&lt;h2 id=&#34;io-virtualization&#34;&gt;I/O virtualization&lt;/h2&gt;
&lt;p&gt;Each guest OS needs to access I/O devices, but the VMM cannot relinquish control of I/O to a single guest OS. Two ways this is accomplished:&lt;/p&gt;
&lt;p&gt;Emulation: Guest I/O operations trap to VMM, which emulates IO in userspace (ex: via QEMU).
Direct I/O: Allocates a slice of a device directly to each VM.&lt;/p&gt;
&lt;h3 id=&#34;communication-between-os-and-device&#34;&gt;Communication between OS and device&lt;/h3&gt;
&lt;p&gt;I/O happens by writing or reading to device registers.&lt;/p&gt;
&lt;p&gt;The operating system can read or write to device registers in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explicit I/O: In and Out instructions write to device memory&lt;/li&gt;
&lt;li&gt;Memory Mapped I/O: Some memory addresses are assigned to device memory rather than RAM.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The hypervisor can be configured to VMExit on I/O. This is because the guest doesn&amp;rsquo;t have direct access to I/O, which is a privileged operation.&lt;/p&gt;
&lt;p&gt;The device raises an interrupt when I/O completes. Modern devices use direct memory access (DMA) to copy data entirely from device memory to RAM before raising an interrupt.&lt;/p&gt;
&lt;h3 id=&#34;io-workflow-in-kvmqemu&#34;&gt;IO workflow in KVM/QEMU&lt;/h3&gt;
&lt;p&gt;There is another thread in qemu to handle IO operations. Example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guest Application calls &lt;code&gt;read&lt;/code&gt; system call.&lt;/li&gt;
&lt;li&gt;Guest OS performs IO operation (can&amp;rsquo;t interface with actual devices though)&lt;/li&gt;
&lt;li&gt;Exits back to hypervisor with exitcode&lt;/li&gt;
&lt;li&gt;Exitcode is handled by QEMU&lt;/li&gt;
&lt;li&gt;QEMU executes call in IO thread and resumes vCPU&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But how does the guest receive interrupts?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When QEMU finishes its IO operation in the IO thread, it raises a virtual interrupt&lt;/li&gt;
&lt;li&gt;QEMU notifies the guest while its running that there is an interrupt pending&lt;/li&gt;
&lt;li&gt;KVM injects the interrupt into the virtual LAPIC.&lt;/li&gt;
&lt;li&gt;On the next cycle, KVM checks for any pending interrupts and handles them accordingly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sources&#34;&gt;Sources&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;VMM Paper: &lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/vmm-intro.pdf&#34;&gt;https://pages.cs.wisc.edu/~remzi/OSTEP/vmm-intro.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IIT Bombay: &lt;a href=&#34;https://www.youtube.com/playlist?list=PLDW872573QAbcpQ7VSUdcm4o3tgnQYBE8&#34;&gt;https://www.youtube.com/playlist?list=PLDW872573QAbcpQ7VSUdcm4o3tgnQYBE8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
